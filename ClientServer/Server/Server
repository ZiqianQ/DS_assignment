package Server;

import java.io.DataInputStream;
import java.io.DataOutputStream;
import java.io.IOException;
import java.io.RandomAccessFile;
import java.net.Socket;
import java.util.Arrays;
import java.util.Iterator;
import java.net.ServerSocket;
import javax.net.ServerSocketFactory;
import javax.print.attribute.standard.OutputDeviceAssigned;

import org.apache.commons.cli.BasicParser;
import org.apache.commons.cli.CommandLine;
import org.apache.commons.cli.CommandLineParser;
import org.apache.commons.cli.HelpFormatter;
import org.apache.commons.cli.Options;
import org.apache.commons.cli.ParseException;

import org.apache.log4j.Logger;
import org.json.simple.JSONArray;
import org.json.simple.JSONObject;
import org.json.simple.parser.JSONParser;
import org.omg.CORBA.PUBLIC_MEMBER;

import com.sun.xml.internal.bind.v2.runtime.unmarshaller.Receiver;

import jdk.internal.dynalink.beans.StaticClass;
import jdk.nashorn.internal.runtime.StoredScript;



public class Server {

	private static int port = 3000;
	static JSONArray Store = new JSONArray();
	
	
	public static void main(String[] args) {
		
		CommandLineParser parser = new BasicParser();
		Options options = new Options();
		
		//command line argument
		options.addOption("advertisedhostname", true, "advertised hostname");
		options.addOption("connectionintervallimit", true, "connection interval limit in seconds");
		options.addOption("exchangeinterval", true, "exchange interval in seconds");;
		options.addOption("port", true, "server port, an integer");
		options.addOption("sevret", true, "secret");
		options.addOption("debug", false, "print debug information");
		
		ServerSocketFactory factory = ServerSocketFactory.getDefault();
		try(ServerSocket server = factory.createServerSocket(port)){
			System.out.println("waiting for connection");
			
			//wait for connection
			while(true){
				
				Socket client = server.accept();
				
				Thread t = new Thread(() ->serverClient(client));
				t.start();
			}
						
		} catch (IOException e) {
			e.printStackTrace();
		}
		
	}
	private static void serverClient(Socket client){
		try(Socket clientServer = client){
			
			//Input stream
			DataInputStream input = new DataInputStream(client.getInputStream());
			
			//Output steam
			DataOutputStream output = new DataOutputStream(client.getOutputStream());
			
			//json parser
			JSONParser parser = new JSONParser();
			
			JSONObject received ; 	
			//initial
		/*	JSONObject initial = new JSONObject();
			initial.put("command", "startup");
			initial.put("name", "mike");
			Store.add(initial);*/
			while (true) {
				while (input.available()>0) {
					received = (JSONObject) parser.parse(input.readUTF());
					
					System.out.println(received.toJSONString());
					System.out.println(received.get("command").toString().toLowerCase());
					switch (received.get("command").toString().toLowerCase()) {
					case "query":
						Query(client);
						break;
					case "publish":
						Publish(client,received);
						break;
					case "share":
						Share(client, received);
						break;
					default:
						JSONObject error = new JSONObject();
						error.put("response", "error");
						error.put("errorMessage", "invalid resourceTemplate");
						output.writeUTF(error.toJSONString());
						output.flush();
//						output.close();
						break;
					}	
				}	
			}		
	
		} catch (IOException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		} catch (org.json.simple.parser.ParseException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
	}
	
	public static void Query(Socket client) {

		try {
		//Input stream
		DataInputStream input = new DataInputStream(client.getInputStream());
		
		//Output steam
		DataOutputStream output;
		
		output = new DataOutputStream(client.getOutputStream());
		
		//reveiced 
		JSONObject message = new JSONObject();
		message.put("response", "sucess");
		output.writeUTF(message.toJSONString());
		output.flush();
		//print the jsonArray
		for (Iterator iterator = Store.iterator();iterator.hasNext();) {
			output.writeUTF(((JSONObject)iterator.next()).toJSONString());
			output.flush();
		}
//		output.close();
		} catch (IOException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
	}
	
	
	public static void Publish(Socket client, JSONObject received) throws IOException{
		try {
			

			//Input stream
			DataInputStream input = new DataInputStream(client.getInputStream());
			
			//Output steam
			DataOutputStream output = new DataOutputStream(client.getOutputStream());

			//stroe the json received from client to jsonArray
			Store.add(received);
			
			//reveiced 
			JSONObject message = new JSONObject();
			message.put("response", "sucess");
			output.writeUTF(message.toJSONString());
			output.flush();
			
			} catch (IOException e) {
				// TODO Auto-generated catch block
				e.printStackTrace();
			}
			
	}

	
	public static void Share(Socket client,JSONObject received) throws IOException, org.json.simple.parser.ParseException{

		//Input stream
				DataInputStream input = new DataInputStream(client.getInputStream());
				
				//Output steam
				DataOutputStream output;
				
				output = new DataOutputStream(client.getOutputStream());
				JSONParser parser = new JSONParser();
		while (true){
 			if(input.available() > 0){
 				String result = input.readUTF();
// 				logger.info("RECEIVED:");
 				System.out.println(result);
 				JSONObject command = (JSONObject) parser.parse(result);
 				if(command.containsKey("uri")){
 					//System.out.println(command.get("uri"));
 					// The file location
						String fileName = "server_files/"+command.get("name");
						// Create a RandomAccessFile to read and write the output file.
						RandomAccessFile downloadingFile = new RandomAccessFile(fileName, "rw");
						// Find out how much size is remaining to get from the server.
						long fileSizeRemaining = (Long) command.get("resourceSize");
						int chunkSize = setChunkSize(fileSizeRemaining);
						
						// Represents the receiving buffer
						byte[] receiveBuffer = new byte[chunkSize];
						// Variable used to read if there are remaining size left to read.
						int num;
						//System.out.println("Downloading "+fileName+" of size "+fileSizeRemaining);
						while((num=input.read(receiveBuffer))>0){
							// Write the received bytes into the RandomAccessFile
							downloadingFile.write(Arrays.copyOf(receiveBuffer, num));
							
							// Reduce the file size left to read..
							fileSizeRemaining-=num;
							
							// Set the chunkSize again
							chunkSize = setChunkSize(fileSizeRemaining);
							receiveBuffer = new byte[chunkSize];
							
							// If you're done then break
							if(fileSizeRemaining==0){
								break;
							}
						}
//						System.out.println("File received!");
						downloadingFile.close();
 				}
 				
 			}
 			else break;
 		}
		//reveiced 
		JSONObject message = new JSONObject();
		message.put("response", "sucess");
		output.writeUTF(message.toJSONString());
		output.flush();
	}
	
	
	private static int setChunkSize(long fileSizeRemaining) {
		// determine the chunksize
		int chunkSize = 1024*1024;
		//if the file size remaining is less than chunksize reset it
		if (fileSizeRemaining<chunkSize) {
			chunkSize=(int) fileSizeRemaining;
		}
		return chunkSize;
	}
}
